#include<bits/stdc++.h>
#ifdef _MSC_VER
#include<intrin.h>
#define __builtin_popcount __popcnt
#define __builtin_popcountll __popcntll
#endif
namespace DS{typedef unsigned int uint;typedef long double ld;constexpr ld PI=3.1415926535897932384626433832795;constexpr ld E=2.7182818284590452353602874713527;constexpr ld PHI=1.6180339887498948482045868343656;constexpr ld GAMMA=0.5772156649015328606065120900824;typedef long long ll;constexpr ll SIXTYNINE=69;constexpr ll MAXR=1000;constexpr ll MAXC=1000;constexpr ll MAXN=1<<19;constexpr ll LOG_MAXN=19;constexpr ll SQRT_MAXN=724; constexpr ll MOD=1000000007;constexpr ll MOD_POW=1; typedef unsigned long long ull;std::vector<std::pair<int,int>>DIRS_RECTILINEAR={{0,1},{1,0},{0,-1},{-1,0}};std::vector<std::pair<int,int>>DIRS_DIAG={{1,1},{1,-1},{-1,1},{-1,-1}};std::vector<std::pair<int,int>>DIRS_ALL={{0,1},{1,0},{0,-1},{-1,0},{1,1},{1,-1},{-1,1},{-1,-1}};std::vector<std::pair<int,int>>DIRS=DIRS_RECTILINEAR;std::random_device rd;std::mt19937_64 rng(rd());std::uniform_int_distribution<int>int_dis(0,std::numeric_limits<int>::max());std::uniform_int_distribution<uint>uint_dis(0,std::numeric_limits<uint>::max());std::uniform_int_distribution<ll>ll_dis(0,std::numeric_limits<ll>::max());std::uniform_int_distribution<ull>ull_dis(0,std::numeric_limits<ull>::max());std::uniform_real_distribution<ld>prob_dist(0,1);template<typename A,typename B>std::ostream&operator<<(std::ostream&out,const std::pair<A,B>&c){out<< "(" <<c.first<< "," <<c.second<< ")";return out;}template<typename T>std::ostream&operator<<(std::ostream&out,const std::vector<T>&v){out<< "[";for(int i=0;i<(int)v.size();++i){out<<v[i];if(i!=v.size()-1)out<< ",";}out<< "]";return out;}
#define printArr0(a,N)for(int i=0;i<N;++i)std::cout<<a[i]<<" ";
#define printArr1(a,N)for(int i=1;i<=N;++i)std::cout<<a[i]<<" ";
#define printArr(a,N)printArr0(a,N);
template<typename T>std::ostream&operator<<(std::ostream&out,const std::queue<T>&q){out<< "<";for(int i=0;i<(int)q.size();++i){out<<q.front();q.push(q.front());q.pop();if(i!=q.size()-1)out<< ",";}out<< ">";return out;}template<typename T>std::ostream&operator<<(std::ostream&out,const std::stack<T>&s){out<< "<";for(int i=0;i<(int)s.size();++i){out<<s.top();s.push(s.top());s.pop();if(i!=s.size()-1)out<< ",";}out<< ">";return out;}template<typename T>std::ostream&operator<<(std::ostream&out,const std::deque<T>&q){out<< "<";for(int i=0;i<(int)q.size();++i){out<<q.front();q.push_back(q.front());q.pop_front();if(i!=q.size()-1)out<< ",";}out<< ">";return out;}template<typename A,typename B>std::ostream&operator<<(std::ostream&out,const std::map<A,B>&m){out<< "{";for(auto it=m.begin();it!=m.end();){out<<it->first<< ':' <<it->second;if(++it!=m.end())out<< ",";}out<< "}";return out;}template<typename A,typename B>std::ostream&operator<<(std::ostream&out,const std::unordered_map<A,B>&m){out<< "{";for(auto it=m.begin();it!=m.end();){out<<it->first<< ':' <<it->second;if(++it!=m.end())out<< ",";}out<< "}";return out;}template<typename T>std::ostream&operator<<(std::ostream&out,const std::set<T>&m){out<< "{";for(auto it=m.begin();it!=m.end();){out<<*it;if(++it!=m.end())out<< ",";}out<< "}";return out;}template<typename T>std::ostream&operator<<(std::ostream&out,const std::unordered_set<T>&m){out<< "{";for(auto it=m.begin();it!=m.end();){out<<*it;if(++it!=m.end())out<< ",";}out<< "}";return out;}template<typename T>std::ostream&operator<<(std::ostream&out,const std::multiset<T>&m){out<< "{";for(auto it=m.begin();it!=m.end();){out<<*it;if(++it!=m.end())out<< ",";}out<< "}";return out;}template<typename T>T gcd(T a,T b){if(b==T(0))return a;else return gcd(b,a%b);}template<typename T>T gcdSlow(T x,T y){while(y!=0){T temp=y;y=x%temp;x=temp;}return x;}template<typename T>T lcm(T a,T b){return(a/gcd(a,b))*b;}template<typename T>T popcount(T x){x-=(x>>1)&0x5555555555555555;x=(x&0x3333333333333333)+((x>>2)&0x3333333333333333);x=(x+(x>>4))&0x0f0f0f0f0f0f0f0f;return(x*0x0101010101010101)>>56;}template<typename T>T sgn(T x){return T(x>0)-T(x<0);}template<typename T>void pMin(T&a,T b){if(b<a)a=b;}template<typename T>void pMax(T&a,T b){if(b>a)a=b;}template<typename T>int reprLen(T obj){std::stringstream s;s<<obj;return s.str().size();}};using namespace std;namespace DS{  enum BIT_mode{RANGE_QUERY_POINT_UPDATE=0,POINT_QUERY_RANGE_UPDATE=1};template<class T,BIT_mode mode,int...Ns>class BIT{private:T val=T(0);public:size_t size()const{return 1;}size_t dimensions()const{return 0;}std::vector<size_t>shape()const{return{};}void addIndex(T v){val+=v;}void subtractIndex(T v){val-=v;}void addRange(T v){val+=v;}void subtractRange(T v){val-=v;}T queryIndex()const{return val;}T querySum()const{return val;}};template<class T,BIT_mode mode,int N,int...Ns>class BIT<T,mode,N,Ns...>{private:BIT<T,mode,Ns...>bit[N+1];public:size_t size()const{return N*bit[0].size();}size_t dimensions()const{return 1+bit[0].dimensions();}std::vector<size_t>shape()const{std::vector<size_t>output={N};std::vector<size_t>inner=bit[0].shape();output.insert(output.end(),inner.begin(),inner.end());return output;}template<typename...Args>void addIndex(int pos,Args...args){assert(0<=pos&&pos<N&& "index out of range");if(mode==RANGE_QUERY_POINT_UPDATE){for(++pos;pos<=N;pos+=pos&-pos)bit[pos].addIndex(args...);}else if(mode==POINT_QUERY_RANGE_UPDATE){for(int x=pos+1;x;x-=x&-x)bit[x].addIndex(args...);for(int x=pos+0;x;x-=x&-x)bit[x].subtractIndex(args...);}}template<typename...Args>void subtractIndex(int pos,Args...args){assert(0<=pos&&pos<N&& "index out of range");assert(mode==POINT_QUERY_RANGE_UPDATE);for(int x=pos+1;x;x-=x&-x)bit[x].subtractIndex(args...);for(int x=pos+0;x;x-=x&-x)bit[x].addIndex(args...);}template<typename...Args>void addRange(int l,int r,Args...args){assert(0<=l&&l<=r&&r<N&& "index out of range");assert(mode==POINT_QUERY_RANGE_UPDATE);for(int x=r+1;x;x-=x&-x)bit[x].addRange(args...);for(int x=l+0;x;x-=x&-x)bit[x].subtractRange(args...);}template<typename...Args>void subtractRange(int l,int r,Args...args){assert(0<=l&&l<=r&&r<N&& "index out of range");assert(mode==POINT_QUERY_RANGE_UPDATE);for(int x=r+1;x;x-=x&-x)bit[x].subtractRange(args...);for(int x=l+0;x;x-=x&-x)bit[x].addRange(args...);}template<typename...Args>T queryIndex(int pos,Args...args)const{assert(0<=pos&&pos<N&& "index out of range");if(mode==RANGE_QUERY_POINT_UPDATE){T res=0;for(int x=pos+1;x;x-=x&-x)res+=bit[x].queryIndex(args...);for(int x=pos+0;x;x-=x&-x)res-=bit[x].queryIndex(args...);return res;}else if(mode==POINT_QUERY_RANGE_UPDATE){T res=0;for(++pos;pos<=N;pos+=pos&-pos)res+=bit[pos].queryIndex(args...);return res;}}template<typename...Args>T querySum(int l,int r,Args...args)const{assert(0<=l&&l<=r&&r<N&& "index out of range");assert(mode==RANGE_QUERY_POINT_UPDATE);T res=0;for(int x=r+1;x;x-=x&-x)res+=bit[x].querySum(args...);for(int x=l+0;x;x-=x&-x)res-=bit[x].querySum(args...);return res;}};template<class T,BIT_mode mode>std::ostream&operator<<(std::ostream&out,const BIT<T,mode>b){out<< "[" <<b.queryIndex()<< "]\n";return out;}template<class T,BIT_mode mode,int N>std::ostream&operator<<(std::ostream&out,const BIT<T,mode,N>b){out<< "[";for(int i=0;i<N;++i)out<<b.queryIndex(i)<< ' ';out<< "]\n";return out;}template<class T,BIT_mode mode,int N,int M>std::ostream&operator<<(std::ostream&out,const BIT<T,mode,N,M>b){out<< "[\n";for(int i=0;i<N;++i){for(int j=0;j<M;++j)out<< ' ' <<b.queryIndex(i,j);out<< '\n';}out<< "]\n";return out;}};namespace DS{  struct CHTLine{ll m,b;  void print(std::ostream&out=std::cout,bool newLine=true)const{out<< "y=" <<m<< " x+" <<b;if(newLine)out<< '\n';}  double intersect(CHTLine a)const{return(double)(b-a.b)/(a.m-m);}  ll eval(ll x)const{return m*x+b;}};std::ostream&operator<<(std::ostream&out,CHTLine line){line.print(out);return out;}  class CHT:public std::vector<CHTLine>{public:  void addLine(CHTLine l){while(size()>=2&&back().intersect(*++rbegin())>=back().intersect(l)){pop_back();}while(!empty()&&back().m==l.m&&back().b>=l.b){pop_back();}push_back(l);}  ll getMinima(ll x)const{if(empty())return std::numeric_limits<ll>::max();int l=-1,r=size()-1;while(l+1<r){int m=(l+r)/2;if((*this)[m].intersect((*this)[m+1])>=x)r=m;else l=m;}return(*this)[r].eval(x);}};  class LiChaoTree{private:CHTLine tree[2*MAXN];public:  LiChaoTree(){}  void addLine(CHTLine line){int node=1,l=0,r=MAXN-1;do{int m=(l+r)/2;bool lGood=line.eval(l)>=tree[node].eval(l);bool mGood=line.eval(m)>=tree[node].eval(m);if(mGood)tree[node]=line;if(lGood!=mGood){node=node*2;r=m;}else{node=node*2+1;l=m+1;}}while(l!=r);}  ll getLine(int x){  int node=1,l=0,r=MAXN-1;ll ans=LLONG_MIN;assert(l<=x&&x<=r&& "x out of range");while(true){ans=std::max(ans,tree[node].eval(x));int m=(l+r)/2;if(l==r)return ans;else if(x<m){node=node*2;r=m;}else{node=node*2+1;l=m+1;}}}};};namespace DS{template<typename T>class Point:public std::complex<T>{public:Point(T x,T y):std::complex<T>(x,y){}void print(std::ostream&out=std::cout,bool newLine=false){out<< '(' <<this->real()<< "," <<this->imag()<< ')';if(newLine)out<< '\n';}const T getX()const{return this->real();}const T getY()const{return this->imag();}Point operator*(T k){return Point(this->real()*k,this->imag()*k);}Point operator*=(T k){*this=*this*k;return*this;}Point operator/(T k){return Point(this->real()/k,this->imag()/k);}Point operator/=(T k){*this=*this/k;return*this;}T dot(Point o){return this->real()*o.real()+this->imag()*o.imag();}T skew(Point o){return this->real()*o.real()-this->imag()*o.imag();}ld length(){return sqrt(this->real()*this->real()+this->imag()*this->imag());}T ccw(Point<T>&q,Point<T>&r){return(q.imag()-this->imag())*(r.real()-q.real())-(q.real()-this->real())*(r.imag()-q.imag());}T orientation(Point<T>&q,Point<T>&r){return sgn(ccw(q,r));}bool isCollinear(Point<T>&q,Point<T>&r){return orientation(q,r)==0;}bool onSegment(Point p,Point q){return std::min(p.real(),q.real())<=this->real()&&this->real()<=std::max(p.real(),q.real())&&std::min(p.imag(),q.imag())<=this->imag()&&this->imag()<=std::max(p.imag(),q.imag());}};template<typename T>std::ostream&operator<<(std::ostream&out,Point<T>val){val.print(out);return out;}template<typename T>class Line{private:Point<T>a,b;public:Line(Point<T>a_,Point<T>b_):a(a_),b(b_){assert(a!=b&& "This is a degenerate line");}void print(std::ostream&out=std::cout,bool newLine=false){out<<a<< "--" <<b;if(newLine)out<< '\n';}const std::pair<Point<T>,Point<T>>getPoints(){return{a,b};}bool intersects(Line<T>&l){T denom=(b-a).skew(l.b-l.a);T numerator1=(b-a).skew(a-l.a);T numerator2=(l.a-a).skew(l.b-l.a);if(denom<0){numerator1=-numerator1;numerator2=-numerator2;denom=-denom;}if(denom==0){return false;}return 0<std::min(numerator1,numerator2)&&std::max(numerator1,numerator2)<denom;}bool intersects2(Line<T>&l){return true;}bool intersects(Point<T>&p){return p.collinear(a,b)&&p.orientation(a,b)==1;}bool touches(Point<T>&p){return p==a||p==b;}};template<typename T>std::ostream&operator<<(std::ostream&out,Line<T>val){val.print(out);return out;}template<typename T>class Polygon{private:std::vector<Point<T>>points;public:Polygon(std::vector<Point<T>>points_,bool makeConvex=true):points(points_){assert(points.size()>=3&& "This is a degenerate polygon");if(makeConvex)makeConvexHull();}void print(std::ostream&out=std::cout,bool newLine=false){out<<points;if(newLine)out<< '\n';}void makeConvexHull(){std::vector<Point<T>>hull;int p=min_element(points.begin(),points.end())-points.begin();do{hull.push_back(points[p]);int best=(p+1)%points.size();for(int i=0;i<points.size();i++){if(orientation(points[p],points[i],points[best])==2)best=i;if(p!=i&&points[p].collinear(points[i],points[best])&&points[best].onSegment(points[p],points[i])){best=i;}}p=best;}while(points[p]!=hull[0]);points=hull;}bool isOnBoundary(Point<T>&point){for(int i0=0;i0<points.size();++i0){int i1=(i0+1)%points.size();if(Line<T>(points[i0],points[i1]).intersects(point))return true;}return false;}bool isContained(Point<T>&point){for(int i0=0;i0<points.size();++i0){int i1=(i0+1)%points.size();T curr=orientation(points[0],points[1],point);if(curr==0||curr!=orientation(points[i0],points[i1],point))return false;}return true;}bool isContained2(Point<T>point){return true;}};template<typename T>std::ostream&operator<<(std::ostream&out,Polygon<T>val){val.print(out);return out;}};
#include<vector>
#include<unordered_set>
#include<set>
#include<iostream>
#include<cassert>
#include<stack>
#include<queue>
#include<map>
#include<limits>
#include<algorithm>
#include<numeric>
namespace DS{template<typename T>class Graph{private:int V;bool isWeighted;bool isDirected;std::vector<std::multiset<std::pair<int,T>>>inEdges;std::vector<std::multiset<std::pair<int,T>>>outEdges;std::multiset<std::pair<std::pair<int,int>,T>>edges;void init(int _V,bool _isWeighted=false,bool _isDirected=false){V=_V;isDirected=_isDirected;isWeighted=_isWeighted;inEdges.resize(V+1);outEdges.resize(V+1);}const bool validNode(int node)const{return 1<=node&&node<=V;}public:Graph(int _V,bool _isWeighted=false,bool _isDirected=false){init(_V,_isWeighted,_isDirected);}Graph(int _V,int M,std::istream&in=std::cin,bool _isWeighted=false,bool _isDirected=false){init(_V,_isWeighted,_isDirected);for(int u,v,i=0;i<M;++i){in>>u>>v;if(isWeighted){T w;in>>w;addEdge(u,v,w);}else addEdge(u,v);}}Graph(int _V,std::vector<std::pair<int,int>>&_edges,bool _isDirected=false){init(_V,false,_isDirected);for(std::pair<int,int>edge:_edges)addEdge(edge.first,edge.second);}Graph(int _V,std::vector<std::pair<std::pair<int,int>,T>>&_edges,bool _isDirected=false){init(_V,true,_isDirected);for(std::pair<std::pair<int,int>,T>edge:_edges)addEdge(edge.first.first,edge.first.second,edge.second);}void print(std::ostream&out=std::cout,bool newLine=true)const{for(int u=1;u<=V;++u){out<<u<< ":\n";for(std::pair<int,T>edge:outEdges[u]){if(!isDirected&&u>edge.first)continue;out<< ' ' <<edge.first;if(isWeighted)out<< "(w=" <<edge.second<< ')';out<< '\n';}}if(newLine)out<< '\n';}inline const size_t size()const{return V;}inline void addEdge(int u,int v,T w=T(1)){if(!isWeighted)assert(w==T(1)&& "Unweighted graphs should only have edges of unit weight");assert(validNode(u)&&validNode(v)&& "Node index out of range");for(int rep=0;rep<=int(!isDirected&&u!=v);++rep){outEdges[u].insert({v,w});inEdges[v].insert({u,w});edges.insert({{u,v},w});std::swap(u,v);}}inline const int addNode(){++V;inEdges.push_back({});outEdges.push_back({});return V;}inline int numEdges(int u,int v)const{assert(validNode(u)&&validNode(v)&& "Node index out of range");auto lowest=edges.lower_bound({{u,v},std::numeric_limits<T>::min()});auto highest=edges.upper_bound({{u,v},std::numeric_limits<T>::max()});return distance(lowest,highest);}inline bool containsEdge(int u,int v)const{assert(validNode(u)&&validNode(v)&& "Node index out of range");auto iter=edges.lower_bound({{u,v},std::numeric_limits<T>::min()});return iter!=edges.end()&&iter->first.first==u&&iter->first.second==v;}inline bool containsEdge(int u,int v,T w)const{assert(validNode(u)&&validNode(v)&& "Node index out of range");assert(isWeighted&& "Can't find weighted edges in an unweighted graph");return edges.find({{u,v},w})!=edges.end();}inline void removeEdge(int u,int v){assert(validNode(u)&&validNode(v)&& "Node index out of range");if(!containsEdge(u,v))return;for(int rep=0;rep<=int(!isDirected&&u!=v);++rep){outEdges[u].erase(outEdges[u].lower_bound({v,std::numeric_limits<T>::min()}),outEdges[u].upper_bound({v,std::numeric_limits<T>::max()}));inEdges[v].erase(inEdges[v].lower_bound({u,std::numeric_limits<T>::min()}),inEdges[v].upper_bound({u,std::numeric_limits<T>::max()}));edges.erase(edges.lower_bound({{u,v},std::numeric_limits<T>::min()}),edges.upper_bound({{u,v},std::numeric_limits<T>::max()}));std::swap(u,v);}}inline void removeEdge(int u,int v,T w){assert(isWeighted&& "Can't remove weighted edges in an unweighted graph");assert(validNode(u)&&validNode(v)&& "Node index out of range");if(!containsEdge(u,v,w))return;for(int rep=0;rep<=int(!isDirected&&u!=v);++rep){outEdges[u].erase({v,w});inEdges[v].erase({u,w});edges.erase({{u,v},w});std::swap(u,v);}}inline const std::multiset<std::pair<int,T>>getEdgesIn(int node)const{assert(validNode(node)&& "Node index out of range");return inEdges[node];}inline const std::multiset<std::pair<int,T>>getEdgesOut(int node)const{assert(validNode(node)&& "Node index out of range");return outEdges[node];}inline const std::multiset<std::pair<int,T>>getEdges(int node)const{assert(validNode(node)&& "Node index out of range");std::multiset<std::pair<int,T>>output=inEdges[node];if(isDirected){output.insert(outEdges[node].begin(),outEdges[node].end());}return output;}inline const std::multiset<std::pair<std::pair<int,int>,T>>getEdges()const{return edges;}inline const size_t degreeIn(int node)const{assert(validNode(node)&& "Node index out of range");return inEdges[node].size();}inline const size_t degreeOut(int node)const{assert(validNode(node)&& "Node index out of range");return outEdges[node].size();}inline const size_t degree(int node)const{assert(validNode(node)&& "Node index out of range");if(isDirected){assert(inEdges[node].size()==outEdges[node].size()&& "Sanity check!");return inEdges[node].size();}else{return inEdges[node].size()+outEdges[node].size();}}inline const std::vector<int>getNodes()const{std::vector<int>output(V);std::iota(output.begin(),output.end(),1);return output;}std::vector<int>getComponentNodes(int root=-1)const{if(root==-1)return getNodes();assert(validNode(root)&& "Node index out of range");std::unordered_set<int>seen;seen.insert(root);std::queue<int>q;q.push(root);while(!q.empty()){int u=q.front();q.pop();for(int type=0;type<=1;++type){for(std::pair<int,T>edge:(type?inEdges:outEdges)[u]){int v=edge.first;if(seen.find(v)==seen.end()){seen.insert(v);q.push(v);}}}}return std::vector<int>(seen.begin(),seen.end());}std::vector<std::vector<int>>getComponentsNodes()const{std::vector<std::vector<int>>output;std::vector<bool>seen=std::vector<bool>(V+1,false);std::queue<int>q;for(int node=1;node<=V;++node){if(!seen[node]){seen[node]=true;q.push(node);output.push_back({node});while(!q.empty()){int u=q.front();q.pop();for(std::pair<int,T>edge:inEdges[u]){int v=edge.first;if(!seen[v]){seen[v]=true;q.push(v);output.back().push_back(v);}}}}}return output;}Graph<T>getSubgraph(int root)const{assert(validNode(root)&& "Node index out of range");Graph<T>output(V,isWeighted,isDirected);for(int u:getComponentNodes(root)){for(std::pair<int,T>edge:outEdges[u]){if(!isDirected&&edge.first>u)break;output.addEdge(u,edge.first,edge.second);}}return output;}Graph<T>operator+(const Graph<T>&o)const{assert(V==o.V&&isDirected==o.isDirected&&isWeighted==o.isWeighted&& "Can't find union of graphs with different properties");Graph<T>*output=new Graph(*this); for(std::pair<std::pair<int,int>,T>edge:o.edges)output->edges.insert({{edge.first.second,edge.first.first},edge.second});for(int node=1;node<=V;++node){output->inEdges[node].insert(output->inEdges[node].end(),o.inEdges[node].begin(),o.inEdges[node].end());output->outEdges[node].insert(output->outEdges[node].end(),o.outEdges[node].begin(),o.outEdges[node].end());}return*output;}Graph<T>operator~()const{Graph<T>output(V,isWeighted,isDirected);for(std::pair<std::pair<int,int>,T>edge:edges)output.edges.insert({{edge.first.second,edge.first.first},edge.second});output.inEdges=outEdges;output.outEdges=inEdges;return output;}inline void clear(){edges.clear();for(int node=1;node<=V;++node){inEdges[node].clear();outEdges[node].clear();}}private:void Dijkstra(int node,std::vector<int>&prevNode,std::vector<T>&dist,bool backwards=false)const{dist[node]=T(0);prevNode[node]=node;std::priority_queue<std::pair<T,int>,std::vector<std::pair<T,int>>,std::greater<std::pair<T,int>>>pq;pq.push({0,node});while(!pq.empty()){int currNode=pq.top().second;T cost=pq.top().first;pq.pop();if(cost>dist[currNode])continue;for(std::pair<int,T>child:(backwards?inEdges:outEdges)[currNode]){if(child.second<0){fill(prevNode.begin(),prevNode.end(),0);fill(dist.begin(),dist.end(),std::numeric_limits<T>::max());BellmanFord(node,prevNode,dist,backwards);return;}T newCost=cost+child.second;if(newCost<dist[child.first]){dist[child.first]=newCost;prevNode[child.first]=currNode;pq.push({newCost,child.first});}}}}void BellmanFord(int node,std::vector<int>&prevNode,std::vector<int>&dist,bool backwards=false)const{for(int rep=0;rep<V;++rep){for(std::pair<std::pair<int,int>,T>edge:edges){int u=edge.first.first,v=edge.first.second;if(backwards)std::swap(u,v);if(dist[u]==std::numeric_limits<T>::max())continue;T newCost=dist[u]+edge.second;if(newCost<dist[v]){assert(rep!=V-1&& "negative weight cycle");dist[v]=newCost;prevNode[v]=u;}}}}public:T shortestDist(int u,int v)const{assert(validNode(u)&&validNode(v)&& "Node index out of range");std::vector<int>prevNode=std::vector<int>(V+1,0);std::vector<T>dist=std::vector<T>(V+1,std::numeric_limits<T>::max());Dijkstra(u,prevNode,dist);return dist[v];}std::pair<T,std::vector<int>>shortestPath(int u,int v)const{assert(validNode(u)&&validNode(v)&& "Node index out of range");std::vector<int>prevNode=std::vector<int>(V+1,0);std::vector<T>dist=std::vector<T>(V+1,std::numeric_limits<T>::max());Dijkstra(u,prevNode,dist);std::vector<int>path;if(dist[v]!=std::numeric_limits<T>::max()){for(int node=v;node!=u;node=prevNode[node])path.push_back(node);path.push_back(u);}reverse(path.begin(),path.end());return{dist[v],path};}T eccentricity(int root)const{assert(validNode(root)&& "Node index out of range");std::vector<int>prevNode=std::vector<int>(V+1,0);std::vector<int>dist=std::vector<int>(V+1,std::numeric_limits<T>::max());Dijkstra(root,prevNode,dist);T furthest=0;for(int node=1;node<=V;++node){if(dist[node]!=std::numeric_limits<T>::max())furthest=std::max(furthest,dist[node]);}return furthest;}std::vector<int>diameter(int root=-1){if(root==-1){std::vector<int>output;for(std::vector<int>&component:getComponentsNodes()){std::vector<int>curr=diameter(component[0]);if(curr.size()>output.size())output=curr;}return output;}assert(validNode(root)&& "Node index out of range");std::vector<int>prevNode=std::vector<int>(V+1,0);std::vector<int>dist=std::vector<int>(V+1,std::numeric_limits<T>::max());Dijkstra(root,prevNode,dist,true);T furthestDist1=std::numeric_limits<T>::min();int furthestNode1=root;for(int node=1;node<=V;++node){if(dist[node]!=std::numeric_limits<T>::max()&&dist[node]>furthestDist1){furthestDist1=dist[node];furthestNode1=node;}}prevNode=std::vector<int>(V+1,0);dist=std::vector<int>(V+1,std::numeric_limits<T>::max());Dijkstra(furthestNode1,prevNode,dist,false);T furthestDist2=std::numeric_limits<T>::min();int furthestNode2=root;for(int node=1;node<=V;++node){if(dist[node]!=std::numeric_limits<T>::max()&&dist[node]>furthestDist2){furthestDist2=dist[node];furthestNode2=node;}}std::vector<int>path;for(int node=furthestNode2;node!=prevNode[node];node=prevNode[node]){path.push_back(node);}path.push_back(furthestNode1);return path;}private:void FloydWarshall(std::vector<std::vector<T>>&dists)const{for(int node=1;node<=V;++node)dists[node][node]=0;for(std::pair<std::pair<int,int>,T>&edge:edges){int u=edge.first.first,v=edge.first.second;dists[u][v]=std::min(dists[u][v],edge.second);}for(int mid=1;mid<=V;++mid){for(int u=1;u<=V;++u){for(int v=1;v<=V;++v){if(std::max(dists[u][mid],dists[mid][v])!=std::numeric_limits<T>::max()){dists[u][v]=std::min(dists[u][v],dists[u][mid]+dists[mid][v]);}}}}}public:std::vector<std::vector<T>>allShortestDist()const{std::vector<std::vector<int>>dists=std::vector<std::vector<int>>(V+1,std::vector<int>(V+1,std::numeric_limits<T>::max()));FloydWarshall();return dists;}private:int DSUgetParent(int node,std::vector<int>&parent)const{if(parent[node]==node)return node;return parent[node]=DSUgetParent(parent[node],parent);}T KruskalCost()const{std::vector<int>parent=std::vector<int>(V+1);std::iota(parent.begin(),parent.end(),0);std::vector<std::pair<T,std::pair<int,int>>>sortedEdges;for(std::pair<std::pair<int,int>,T>edge:edges){sortedEdges.push_back({edge.second,edge.first});}sort(sortedEdges.begin(),sortedEdges.end());T cost=0;for(std::pair<T,std::pair<int,int>>&edge:sortedEdges){int parentU=DSUgetParent(edge.second.first,parent),parentV=DSUgetParent(edge.second.second,parent);if(parentU!=parentV){cost+=edge.first;parent[parentU]=parentV;}}return cost;}Graph<T>Kruskal()const{std::vector<int>parent=std::vector<int>(V+1);std::iota(parent.begin(),parent.end(),0);std::vector<std::pair<T,std::pair<int,int>>>sortedEdges;for(std::pair<std::pair<int,int>,T>edge:edges){sortedEdges.push_back({edge.second,edge.first});}sort(sortedEdges.begin(),sortedEdges.end());Graph<T>output(V,isWeighted,isDirected);for(std::pair<T,std::pair<int,int>>&edge:sortedEdges){int parentU=DSUgetParent(edge.second.first,parent),parentV=DSUgetParent(edge.second.second,parent);if(parentU!=parentV){output.addEdge(parentU,parentV,edge.first);parent[parentU]=parentV;}}return output;}public:T MSTcost()const{return KruskalCost();}Graph<T>MST()const{return Kruskal();}private:int Tarjan(int u,int index,std::vector<std::vector<int>>&components,std::vector<int>&s,std::vector<bool>&seen,std::vector<int>&getIndex,std::vector<int>&lowLink){getIndex[u]=lowLink[u]=index;++index;s.push_back(u);seen[u]=true;for(std::pair<int,T>edge:outEdges[u]){int v=edge.first;if(getIndex[v]==-1){index=Tarjan(v,index,components,s,seen,getIndex,lowLink);lowLink[u]=std::min(lowLink[u],lowLink[v]);}else if(seen[v]){lowLink[u]=std::min(lowLink[u],getIndex[v]);}}if(getIndex[u]==lowLink[u]){components.push_back({});int node;do{node=s.back();s.pop_back();seen[node]=false;components.back().push_back(node);}while(node!=u);}return index;}public:std::vector<std::vector<int>>getSCCnodes()const{std::vector<bool>seen=std::vector<bool>(V+1,false);std::vector<int>getIndex=std::vector<int>(V+1,-1);std::vector<int>lowLink=std::vector<int>(V+1,0);std::vector<std::vector<int>>components;std::vector<int>s;for(int node=1;node<=V;++node){if(getIndex[node]==-1)Tarjan(node,1,components,s,seen,getIndex,lowLink);}return components;}std::vector<int>getSCCnodes(int root)const{assert(isDirected&& "In an undirected graph,all components are strongly connected components");assert(validNode(root)&& "Node index out of range");std::vector<bool>seen=std::vector<bool>(V+1,false);std::vector<int>getIndex=std::vector<int>(V+1,-1);std::vector<int>lowLink=std::vector<int>(V+1,0);std::vector<std::vector<int>>components;std::vector<int>s;Tarjan(root,1,components,s,seen,getIndex,lowLink);assert(components.size()==1&& "Sanity check!");return components[0];}private:int _getBridges(int u,int parent,int t,std::vector<std::pair<std::pair<int,int>,T>>&bridges,std::vector<bool>&seen,std::vector<int>&minTime,std::vector<int>&entryTime)const{seen[u]=true;minTime[u]=entryTime[u]=++t;for(std::pair<int,T>child:outEdges[u]){int v=child.first;T w=child.second;if(v==parent)continue;if(seen[v]){minTime[u]=std::min(minTime[u],entryTime[v]);}else{t=_getBridges(v,u,t,bridges,seen,minTime,entryTime);minTime[u]=std::min(minTime[u],minTime[v]);if(minTime[v]>entryTime[u]){if(numEdges(u,v)==1)bridges.push_back({{u,v},w});}}}return t;}public:std::vector<std::pair<std::pair<int,int>,T>>getBridges(int root=-1)const{std::vector<bool>seen=std::vector<bool>(V+1,false);std::vector<int>minTime=std::vector<int>(V+1,0),entryTime=std::vector<int>(V+1,0);std::vector<std::pair<std::pair<int,int>,T>>bridges;if(root==-1){for(int node=1;node<=V;++node){if(!seen[node])_getBridges(node,-1,0,bridges,seen,minTime,entryTime);}}else{assert(validNode(root)&& "Node index out of range");_getBridges(root,-1,0,bridges,seen,minTime,entryTime);}return bridges;}private:void _greedyColouring(int node,std::vector<int>&colours)const{if(colours[node]!=-1)return;std::set<int>usedColours;for(std::pair<int,T>edge:getEdges(node))usedColours.insert(colours[edge.first]);for(colours[node]=0;usedColours.find(colours[node])!=usedColours.end();++colours[node]);for(std::pair<int,T>edge:getEdges(node))_greedyColouring(edge.first,colours);}public:std::vector<int>greedyColouring(int root=-1)const{assert((root==-1||validNode(root))&& "Node index out of range");std::vector<int>colours(V+1,-1);for(int node:getComponentNodes(root))_greedyColouring(node,colours);return colours;}private:std::vector<int>Kahn(int root=-1)const{std::vector<int>depths=std::vector<int>(V+1,0);std::vector<int>q,topSort;for(int node:getComponentNodes(root)){depths[node]=inEdges[node].size();if(inEdges[node].empty())q.push_back(node);}while(!q.empty()){int u=q.back();q.pop_back();topSort.push_back(u);for(std::pair<int,T>edge:outEdges[u]){int v=edge.first;depths[v]--;if(depths[v]==0)q.push_back(v);}}return topSort;}void dfsTopSort(int node,std::vector<int>&topSort,std::vector<int>&state)const{if(state[node]==2)return;assert(state[node]==1&& "Graph contains cycle");state[node]=1;for(std::pair<int,T>edge:outEdges[node])dfsTopSort(edge.first,topSort,state);state[node]=2;topSort.push_back(node);}public:std::vector<int>getTopSort(int root=-1,bool doKahn=false)const{assert(isDirected&& "Can't get a topological sort for a bidirectional graph");assert((root==-1||validNode(root))&& "Node index out of range");if(doKahn){std::vector<int>topSort=Kahn(root);assert(topSort.size()<=V&& "Sanity check!");assert(topSort.size()==V&& "Graph contains cycle");return topSort;}else{std::vector<int>state=std::vector<int>(V+1,0);std::vector<int>topSort;for(int node:getComponentNodes(root))dfsTopSort(node,topSort,state);reverse(topSort.begin(),topSort.end());return topSort;}}private:T addFlow(int source,int sink,const std::vector<int>&prev,std::map<std::pair<int,int>,T>&remainingCap)const{T newFlow=std::numeric_limits<T>::max();for(int u=sink;u!=source;u=prev[u]){newFlow=std::min(newFlow,remainingCap[{prev[u],u}]);}for(int u=sink;u!=source;u=prev[u]){remainingCap[{prev[u],u}]-=newFlow;remainingCap[{u,prev[u]}]+=newFlow;}return newFlow;}public:T maxFlow(int source,int sink,bool doSlow=false)const{assert(validNode(source)&&validNode(sink)&& "Node index out of range");if(source==sink)return std::numeric_limits<T>::max();std::map<std::pair<int,int>,T>remainingCap;for(std::pair<std::pair<int,int>,T>edge:edges){remainingCap[edge.first]+=edge.second;}T totalFlow=T(0);while(true){std::vector<int>prev=std::vector<int>(V+1,-1);std::vector<int>levels=std::vector<int>(V+1,-1);std::queue<int>q;levels[source]=0;q.push(source);while(!q.empty()){int u=q.front();q.pop();for(int type=0;type<=1;++type){for(std::pair<int,T>edge:(type?inEdges:outEdges)[u]){int v=edge.first;if(prev[v]==-1&&remainingCap[{u,v}]>0){prev[v]=u;levels[v]=levels[u]+1;q.push(v);}}}}if(prev[sink]==-1)return totalFlow;if(doSlow){totalFlow+=addFlow(source,sink,prev,remainingCap);}else{int newFlow;do{std::stack<int>s;s.push(source);while(!s.empty()&&s.top()!=sink){int u=s.top();s.pop();for(int type=0;type<=1;++type){for(std::pair<int,T>edge:(type?inEdges:outEdges)[u]){int v=edge.first;if(levels[v]==levels[u]+1&&remainingCap[{u,v}]>0){prev[v]=u;q.push(v);}}}}newFlow=addFlow(source,sink,prev,remainingCap);totalFlow+=newFlow;}while(newFlow!=0);}}}inline const bool isDirectedGraph()const{return isDirected;}inline const bool isWeightedGraph()const{return isWeighted;}bool hasSelfEdges(int root=-1)const{assert((root==-1||validNode(root))&& "Node index out of range");for(int node:getComponentNodes(root)){if(containsEdge(node,node))return true;}return false;}bool hasDoubleEdges(int root=-1)const{for(int node:getComponentNodes(root)){for(int type=0;type<=1;++type){const std::multiset<std::pair<int,T>>*currEdges=&(type?inEdges[node]:outEdges[node]);if(currEdges->empty())continue;for(auto it1=currEdges->begin(),it2=++currEdges->begin();it2!=currEdges->end();++it1,++it2){if(it1->first==it2->first)return true;}}}return false;}bool hasCycle(int root=-1)const{assert((root==-1||validNode(root))&& "Node index out of range");return(int)Kahn(root).size()<V;}bool isSimpleGraph(int root=-1)const{assert((root==-1||validNode(root))&& "Node index out of range");return!hasSelfEdges(root)&&!hasDoubleEdges(root);}bool isDAG(int root=-1)const{assert((root==-1||validNode(root))&& "Node index out of range");return isDirected&&!hasCycle(root);}bool isTree(int root=-1)const{assert((root==-1||validNode(root))&& "Node index out of range");if(hasCycle(root)||hasDoubleEdges(root))return false;std::vector<int>component=getComponentNodes(root);int numEdges=0,numLeaves=0,numRoots=0;for(int node:component){for(std::pair<int,T>edge:outEdges[node]){if(!isDirected&&edge.first>node)break;else++numEdges;}numLeaves+=outEdges[node].empty();numRoots+=inEdges[node].empty();}if(isDirected&&numLeaves>1&&numRoots>1)return false;return numEdges==component.size()-1; }}bool isForest()const{for(std::vector<int>&component:getComponentsNodes()){if(!isTree(component[0]))return false;}return true;}};template<typename T>std::ostream&operator<<(std::ostream&out,Graph<T>graph){graph.print(out);return out;}};namespace DS{template<typename T>class Grid{private:int R=0;int C=0;std::vector<std::vector<T>>grid;std::vector<std::vector<T>>prefix;bool hasPrecomp=false;void init(int _R,int _C){R=_R;C=_C;grid=std::vector<std::vector<T>>(R);for(int r=0;r<R;++r)grid[r]=std::vector<T>(C);prefix=std::vector<std::vector<T>>(R+1);for(int r=0;r<R+1;++r)prefix[r]=std::vector<T>(C+1);}public:Grid(){}Grid(int _R,int _C,T val=T(0)){init(_R,_C);for(int r=0;r<R;++r){for(int c=0;c<C;++c){grid[r][c]=val;}}}Grid(int _R,int _C,std::istream&in){init(_R,_C);for(int r=0;r<R;++r){for(int c=0;c<C;++c){in>>grid[r][c];}}buildPrefix();}template<size_t rows,size_t cols>Grid(T(&_grid)[rows][cols]){init(sizeof(_grid)/sizeof(_grid[0]),sizeof(_grid[0])/sizeof(T));for(int r=0;r<R;++r){for(int c=0;c<C;++c){grid[r][c]=_grid[r][c];}}buildPrefix();}Grid(std::vector<std::vector<T>>_grid){init((int)_grid.size(),(int)_grid[0].size());for(int r=0;r<R;++r){assert(_grid[r].size()==grid[0].size()&& "Invalid grid shape");grid[r]=_grid[r];}buildPrefix();}void buildPrefix(){hasPrecomp=true;for(int r=0;r<R;++r){for(int c=0;c<C;++c){prefix[r+1][c+1]=grid[r][c]+(prefix[r+1][c]+prefix[r][c+1]-prefix[r][c]);}}}void print(std::ostream&out=std::cout,bool newLine=true)const{for(int r=0;r<R;++r){for(int c=0;c<C;++c){out<<grid[r][c]<< ' ';}out<< '\n';}if(newLine)out<< '\n';}void pprint(std::ostream&out=std::cout,bool newLine=true,int spacing=-1){if(spacing==-1){for(int r=0;r<R;++r){for(int c=0;c<C;++c)spacing=std::max(spacing,(reprLen(grid[r][c])+3)/4);}}std::string sep= "+",space= "|";for(int r=0;r<R;++r){sep+=std::string(4*spacing+1, '-')+ '+';space+=std::string(4*spacing+1, ' ')+ '|';}sep+= '\n';space+= '\n';for(int r=0;r<R;++r){out<<sep;for(int rep=0;rep<spacing;++rep)out<<space;out<< '|';for(int c=0;c<C;++c){int paddingL=std::max(0,2*spacing-reprLen(grid[r][c])/2);int paddingR=std::max(0,2*spacing-(reprLen(grid[r][c])-1)/2);out<<std::string(paddingL, ' ')<<grid[r][c]<<std::string(paddingR, ' ')<< '|';}out<< '\n';for(int rep=0;rep<spacing;++rep)out<<space;}out<<sep;if(newLine)out<< '\n';}std::function<bool(int,int)>compEQ(T val){return[&,val](int r,int c){if(validCoord(r,c))return getVal(r,c)==val;return false;};}std::function<bool(int,int)>compNE(T val){return[&,val](int r,int c){if(validCoord(r,c))return getVal(r,c)!=val;return false;};}std::function<bool(int,int)>compGT(T val){return[&,val](int r,int c){if(validCoord(r,c))return getVal(r,c)>val;return false;};}std::function<bool(int,int)>compGE(T val){return[&,val](int r,int c){if(validCoord(r,c))return getVal(r,c)>=val;return false;};}std::function<bool(int,int)>compLT(T val){return[&,val](int r,int c){if(validCoord(r,c))return getVal(r,c)<val;return false;};}std::function<bool(int,int)>compLE(T val){return[&,val](int r,int c){if(validCoord(r,c))return getVal(r,c)<=val;return false;};}std::function<bool(int,int)>compAny(){return[](int r,int c){return true;};}inline const int getR()const{return R;}inline const int getC()const{return C;}inline const int size()const{return R*C;}inline bool validCoord(int r,int c)const{return 0<=r&&r<R&&0<=c&&c<C;}inline bool validCoord(std::pair<int,int>coord)const{return validCoord(coord.first,coord.second);}std::pair<int,int>findVal(std::function<bool(int,int)>isValid){for(int r=0;r<R;++r){for(int c=0;c<C;++c){if(isValid(r,c))return{r,c};}}return{-1,-1};}inline bool containsVal(std::function<bool(int,int)>isValid)const{return findVal(isValid).first!=-1;}std::vector<std::pair<int,int>>findAllVal(std::function<bool(int,int)>isValid)const{std::vector<std::pair<int,int>>output;for(int r=0;r<R;++r){for(int c=0;c<C;++c){if(isValid(r,c))output.push_back({r,c});}}return output;}int count(std::function<bool(int,int)>isValid)const{int total=0;for(int r=0;r<R;++r){for(int c=0;c<C;++c)total+=(bool)isValid(r,c);}return total;}inline void setVal(int r,int c,T val){if(validCoord(r,c)){hasPrecomp=false;grid[r][c]=val;}}void setVal(std::pair<int,int>coord,T val){setVal(coord.first,coord.second,val);}void setVals(int r1,int c1,int r2,int c2,T val){hasPrecomp=false;if(r1>r2)std::swap(r1,r2);if(c1>c2)std::swap(c1,c2);r1=std::max(0,r1);c1=std::max(0,c1);r2=std::min(R-1,r2);c2=std::max(C-1,c2);for(int r=r1;r<=r2;++r){for(int c=c1;c<=c2;++c)grid[r][c]=val;}}void setVals(std::pair<int,int>coord1,std::pair<int,int>coord2,T val){setVals(coord1.first,coord1.second,coord2.first,coord2.second,val);}void incrVal(int r,int c,T val){if(validCoord(r,c)){hasPrecomp=false;grid[r][c]+=val;}}void incrVal(std::pair<int,int>coord,T val){incrVal(coord.first,coord.second,val);}void incrVals(int r1,int c1,int r2,int c2,T val){hasPrecomp=false;if(r1>r2)std::swap(r1,r2);if(c1>c2)std::swap(c1,c2);r1=std::max(0,r1);c1=std::max(0,c1);r2=std::min(R-1,r2);c2=std::max(C-1,c2);for(int r=r1;r<=r2;++r){for(int c=c1;c<=c2;++c)grid[r][c]+=val;}}void incrVals(std::pair<int,int>coord1,std::pair<int,int>coord2,T val){incrVals(coord1.first,coord1.second,coord2.first,coord2.second,val);}T getVal(int r,int c,T defaultVal=T())const{if(validCoord(r,c))return grid[r][c];return defaultVal;}T getVal(std::pair<int,int>coord,T defaultVal=T())const{return getVal(coord.first,coord.second,defaultVal);}T sumVals(int r1,int c1,int r2,int c2)const{if(r1>r2)std::swap(r1,r2);if(c1>c2)std::swap(c1,c2);r1=std::max(0,r1);c1=std::max(0,c1);r2=std::min(R-1,r2);c2=std::max(C-1,c2);if(hasPrecomp){return prefix[r2+1][c2+1]+prefix[r1][c1]-prefix[r2+1][c1]-prefix[r1][c2+1];}else{T total=0;for(int r=r1;r<=r2;++r){for(int c=c1;c<=c2;++c)total+=grid[r][c];}return total;}}T sumVals(std::pair<int,int>coord1,std::pair<int,int>coord2)const{return sumVals(coord1.first,coord1.second,coord2.first,coord2.second);}bool operator==(Grid o)const{if(R!=o.getR()||C!=o.getC())return false;for(int r=0;r<R;++r){for(int c=0;c<C;++c){if(grid[r][c]!=o.getVal(r,c))return false;}}return true;}Grid<T>flipRows()const{Grid<T>output(R,C,0);for(int r=0;r<R;++r){for(int c=0;c<C;++c)output.setVal(R-r-1,c,grid[r][c]);}return output;}Grid<T>flipCols()const{Grid<T>output(R,C,0);for(int r=0;r<R;++r){for(int c=0;c<C;++c)output.setVal(r,C-c-1,grid[r][c]);}return output;}Grid<T>rot180()const{return flipRows().flipCols();}Grid<T>flipPrimaryDiag()const{Grid<T>output(C,R,0);for(int r=0;r<R;++r){for(int c=0;c<C;++c)output.setVal(c,r,grid[r][c]);}return output;}Grid<T>flipSecondaryDiag()const{return rot180().flipPrimaryDiag();}Grid<T>rotClockwise(){return flipPrimaryDiag().flipCols();}Grid<T>rotAnticlockwise()const{return flipPrimaryDiag().flipRows();}Grid<T>replace(T prevVal,T newVal)const{Grid<T>*output=new Grid<T>(*this); for(int r=0;r<R;++r){for(int c=0;c<C;++c){if(output->getVal(r,c)==prevVal)output->setVal(r,c,newVal);}}return*output;}std::vector<std::pair<int,int>>getRowCoords(int r)const{std::vector<std::pair<int,int>>output;for(int c=0;c<C;++c)output.push_back({r,c});return output;}std::vector<std::pair<int,int>>getColCoords(int c)const{std::vector<std::pair<int,int>>output;for(int r=0;r<R;++r)output.push_back({r,c});return output;}std::vector<std::pair<int,int>>getAllCoords()const{std::vector<std::pair<int,int>>output;for(int r=0;r<R;++r){for(int c=0;c<C;++c){output.push_back({r,c});}}return output;}std::vector<std::pair<int,int>>getSomeCoords(std::function<bool(int,int)>isValid)const{std::vector<std::pair<int,int>>output;for(int r=0;r<R;++r){for(int c=0;c<C;++c){if(isValid(r,c))output.push_back({r,c});}}return output;}std::vector<std::pair<int,int>>getAdjCoords(int r,int c,std::vector<std::pair<int,int>>&dirs)const{std::vector<std::pair<int,int>>output;for(std::pair<int,int>dir:dirs){int newR=r+dir.first,newC=c+dir.second;if(validCoord(r,c)&&validCoord(newR,newC))output.push_back({newR,newC});}return output;}std::vector<std::pair<int,int>>getAdjCoords(std::pair<int,int>coord,std::vector<std::pair<int,int>>&dirs)const{return getAdjCoords(coord.first,coord.second,dirs);}private:void bfs(int r,int c,std::function<bool(int,int)>isValid,std::vector<std::pair<int,int>>dirs,std::vector<std::vector<int>>&depth,int maxD=INT_MAX)const{if(!validCoord(r,c))return;if(!isValid(r,c))return;std::queue<std::pair<int,int>>q;q.push({r,c});depth[r][c]=0;for(int d=1;!q.empty()&&d<maxD;++d){int size=q.size();for(int i=0;i<size;++i){auto curr=q.front();q.pop();for(std::pair<int,int>adj:getAdjCoords(curr.first,curr.second,dirs)){if(depth[adj.first][adj.second]==-1&&isValid(adj.first,adj.second)){q.push(adj);depth[adj.first][adj.second]=d;}}}}}void bfs(std::pair<int,int>coord,std::function<bool(int,int)>isValid,std::vector<std::pair<int,int>>&dirs,std::vector<std::vector<int>>&depth,int maxD=INT_MAX)const{return bfs(coord,isValid,dirs,depth);}public:std::vector<std::pair<int,int>>getRegion(int startR,int startC,std::function<bool(int,int)>isValid,std::vector<std::pair<int,int>>&dirs)const{std::vector<std::vector<int>>depth=std::vector<std::vector<int>>(R,std::vector<int>(C,-1));bfs(startR,startC,isValid,dirs,depth);std::vector<std::pair<int,int>>output;for(int r=0;r<R;++r){for(int c=0;c<C;++c){if(depth[r][c]>=0)output.push_back({r,c});}}return output;}std::vector<std::pair<int,int>>getRegion(std::pair<int,int>coord,std::function<bool(int,int)>isValid,std::vector<std::pair<int,int>>&dirs)const{return getRegion(coord.first,coord.second,isValid,dirs);}std::vector<std::vector<std::pair<int,int>>>getRegions(std::function<bool(int,int)>isValid,std::vector<std::pair<int,int>>&dirs)const{std::vector<std::vector<int>>depth=std::vector<std::vector<int>>(R,std::vector<int>(C,-1));std::vector<std::vector<std::pair<int,int>>>output;for(int r=0;r<R;++r){for(int c=0;c<C;++c){if(depth[r][c]==-1&&isValid(r,c)){bfs(r,c,isValid,dirs,depth);output.push_back(getRegion(r,c,isValid,dirs));}}}return output;}bool isSurroundedBy(int startR,int startC,std::function<bool(int,int)>isValid,std::function<bool(int,int)>isBoundary,std::vector<std::pair<int,int>>&dirs)const{std::vector<std::vector<int>>depth=std::vector<std::vector<int>>(R,std::vector<int>(C,-1));bfs(startR,startC,isValid,dirs,depth);for(int r=0;r<R;++r){for(int c=0;c<C;++c){if(isValid(r,c)){for(std::pair<int,int>adj:getAdjCoords(r,c,dirs)){if(!isValid(adj.first,adj.second)&&!isBoundary(adj.first,adj.second))return false;}}}}return true;}bool isSurroundedBy(std::pair<int,int>coord,T val,std::function<bool(int,int)>isValid,std::function<bool(int,int)>isBoundary,std::vector<std::pair<int,int>>&dirs)const{return isSurroundedBy(coord.first,coord.second,val,isValid,isBoundary,dirs);}std::vector<std::pair<int,int>>shortestPath(int r1,int c1,int r2,int c2,std::function<bool(int,int)>isValid,std::vector<std::pair<int,int>>&dirs)const{std::vector<std::vector<int>>depth=std::vector<std::vector<int>>(R,std::vector<int>(C,-1));bfs(r2,c2,isValid,dirs,depth);assert(depth[r1][c1]!=-1&& "No path found");std::vector<std::pair<int,int>>output;for(int r=r1,c=c1;!(r==r2&&c==c2);){output.push_back({r,c});for(std::pair<int,int>adj:getAdjCoords(r,c,dirs)){int newDepth=depth[adj.first][adj.second];if(newDepth!=-1&&newDepth<depth[r][c]){r=adj.first;c=adj.second;}}}output.push_back({r2,c2});return output;}std::vector<std::pair<int,int>>shortestPath(std::pair<int,int>coord1,std::pair<int,int>coord2,std::function<bool(int,int)>isValid,std::vector<std::pair<int,int>>&dirs)const{return shortestPath(coord1.first,coord1.second,coord2.first,coord2.second,isValid,dirs);}};template<typename T>std::ostream&operator<<(std::ostream&out,const Grid<T>grid){grid.print(out);return out;}};namespace DS{template<typename T>class Matrix:public Grid<T>{public:using Grid<T>::Grid;Matrix(int N):Matrix(N,N,0){for(int i=0;i<N;++i)this->setVal(i,i,1);}Matrix(Grid<T>g):Grid<T>(g){}void print(std::ostream&out=std::cout,bool newLine=true)const{out<< "[\n";for(int r=0;r<this->getR();++r){out<< ' ';for(int c=0;c<this->getC();++c)out<<this->getVal(r,c)<< ' ';out<< '\n';}std::cout<< "]\n";if(newLine)std::cout<< '\n';}Matrix transpose()const{return Matrix(this->flipPrimaryDiag());}T trace(){assert(this->getR()==this->getC()&& "Can't calculate trace of non-square matrix");T total=T(0);for(int i=0;i<this->getR();++i)total+=this->getVal(i,i);return total;}Matrix operator+(Matrix o)const{assert(this->getC()==o.getC()&&this->getR()==o.getR()&& "Can't add matricies of different shapes");Matrix*output=new Matrix<T>(*this);for(int r=0;r<this->getR();++r){for(int c=0;c<this->getC();++c){output->incrVal(r,c,o.getVal(r,c));}}return*output;}void operator+=(Matrix o){*this=*this+o;}Matrix operator-(Matrix o)const{assert(this->getC()==o.getC()&&this->getR()==o.getR()&& "Can't subtract matricies of different shapes");Matrix*output=new Matrix<T>(*this);for(int r=0;r<this->getR();++r){for(int c=0;c<this->getC();++c){output->incrVal(r,c,-o.getVal(r,c));}}return*output;}void operator-=(Matrix o){*this=*this-o;}Matrix operator*(ll mul)const{Matrix*output=new Matrix<T>(*this);for(int r=0;r<this->getR();++r){for(int c=0;c<this->getC();++c){output->setVal(r,c,mul*this->getVal(r,c));}}return*output;}void operator*=(ll mul){*this=*this*mul;}Matrix operator*(Matrix o)const{assert(this->getC()==o.getR()&& "Invalid shapes for multiplication");Matrix output(this->getR(),o.getC(),0);for(int r=0;r<this->getR();++r){for(int c=0;c<o.getC();++c){for(int i=0;i<this->getC();++i){output.incrVal(r,c,this->getVal(r,i)*o.getVal(i,c));}}}return output;}void operator*=(Matrix o){*this=*this*o;}Matrix pow(ll p)const{assert(this->getR()==this->getC()&& "Only square matricies can be raised to a power");assert(p>=0&& "Inversion of matricies hasn't been implmeneted");Matrix output((int)this->getR());for(Matrix*curr=new Matrix(*this);p;p/=2,*curr=(*curr)*(*curr)){if(p&1)output*=*curr;}return output;}};template<typename T>std::ostream&operator<<(std::ostream&out,const Matrix<T>mat){mat.print(out);return out;}};namespace DS{class ModInt{private:ll num;public:ModInt(ll _num=0){while(_num<0)_num+=MOD;num=(_num+MOD)%MOD;assert(0<=num&&num<MOD);}void print(std::ostream&out=std::cout,bool newLine=false)const{out<<num<< "(mod " <<MOD<< ")";if(newLine)out<< '\n';}const ll getNum()const{return num;}bool operator==(ModInt o)const{return num==o.num;}bool operator==(ll o)const{return num==o;}bool operator!=(ModInt o)const{return num!=o.num;}bool operator!=(ll o)const{return num!=o;}ModInt operator+(ModInt o)const{return ModInt(num+o.num);}ModInt operator+=(ModInt o){*this=*this+o;return*this;}ModInt operator++(){*this=*this+1;return*this;}ModInt operator++(int){ModInt tmp=*this;*this=*this+1;return tmp;}ModInt operator-(ModInt o)const{return ModInt(num-o.num);}ModInt operator-=(ModInt o){*this=*this-o;return*this;}ModInt operator--(){*this=*this-1;return*this;}ModInt operator--(int){ModInt tmp=*this;*this=*this-1;return tmp;}ModInt operator*(ModInt o)const{return ModInt(num*o.num);}void operator*=(ModInt o){*this=*this*o;}ModInt pow(ll x)const{assert(x>=0);ModInt output(1);for(ModInt curr(num);x;x/=2){if(x&1)output*=curr;curr*=curr;}return output;}ModInt modInv()const{ModInt x0(0),x1(1);ll r0=MOD,r1=num;while(r1){ll q=r0/r1;x0-=x1*q;std::swap(x0,x1);r0-=r1*q;std::swap(r0,r1);}return x0;}};std::ostream&operator<<(std::ostream&out,const ModInt val){val.print(out);return out;}};namespace DS{template<typename T>class Polynomial{private:std::vector<T>coeff;public:Polynomial(){}Polynomial(std::vector<T>_coeff):coeff(_coeff){}void print(std::ostream&out=std::cout,bool newLine=false)const{out<<coeff;if(newLine)out<< '\n';}void pprint(std::ostream&out=std::cout,bool newLine=false)const{for(int d=deg();d>=0;--d)std::cout<<coeff[d]<< " x^" <<d<< ' ';if(newLine)out<< '\n';}int N()const{return coeff.size();}int deg()const{return this->norm().N()-1;}Polynomial<T>norm()const{Polynomial<T>*copy=new Polynomial<T>(*this);while(copy->coeff.back()==0ll)copy->coeff.pop_back();return*copy;}Polynomial<T>mod(int k)const{Polynomial<T>*copy=new Polynomial<T>(*this);while(copy->N()>k)copy->coeff.pop_back();return*copy;}Polynomial<T>rev()const{Polynomial<T>*copy=new Polynomial<T>(*this);reverse(copy->coeff.begin(),copy->coeff.end());return*copy;}Polynomial<T>inv(int t)const{assert(t!=0);if(t==1)return Polynomial<T>({coeff[0].modInv()});Polynomial<T>q=this->inv((t+1)/2);Polynomial<T>one({1});Polynomial<T>inv=(q-((*this)*q-one)*q).mod(t); return inv;}T eval(T x)const{T total=T(0);for(int i=N()-1;i>=0;--i){total=total*x+coeff[i];}return total;}bool operator==(Polynomial<T>o)const{int deg=this->deg();int oDeg=o.deg();if(deg!=oDeg)return false;for(int i=0;i<deg;++i){if(coeff[i]!=o.coeff[i])return false;}return true;}bool operator!=(Polynomial<T>o)const{int deg=this->deg();int oDeg=o.deg();if(deg!=oDeg)return true;for(int i=0;i<deg;++i){if(coeff[i]!=o.coeff[i])return true;}return false;}std::vector<T>NTT(int n,bool inv=false)const{assert(popcount(n)==1);std::vector<T>a=coeff;a.resize(n);for(int i=1,j=0;i<n;++i){int bit=n/2;for(;j>=bit;bit/=2)j-=bit;j+=bit;if(i<j)std::swap(a[i],a[j]);}for(int len=2;len<=n;len*=2){assert(MOD>2);T wlen=2;if(inv)wlen=wlen.modInv();for(int i=len;i<MOD_POW;i*=2)wlen*=wlen;for(int i=0;i<n;i+=len){T w=1;for(int j=0;j<len/2;++j){T u=a[i+j];T v=a[i+j+len/2]*w;a[i+j]=u+v;a[i+j+len/2]=u-v;w*=wlen;}}}if(inv){T nInv=T(n).modInv();for(int i=0;i<n;++i)a[i]*=nInv;}return a;}std::vector<T>FFT(int n,bool inv=false)const{}std::vector<T>FT(int n,bool inv=false)const{return NTT(n,inv);}}Polynomial<T>operator+(Polynomial<T>o)const{Polynomial<T>copy;for(int i=0;i<std::max(N(),o.N());++i){copy.coeff.push_back((i<N()?coeff[i]:0)+(i<o.N()?o.coeff[i]:0));}return copy;}Polynomial<T>operator+=(Polynomial<T>o){*this=(*this)+o;return*this;}Polynomial<T>operator-(Polynomial<T>o)const{Polynomial<T>copy;for(int i=0;i<std::max(N(),o.N());++i){copy.coeff.push_back((i<N()?coeff[i]:0)-(i<o.N()?o.coeff[i]:0));}return copy;}Polynomial<T>operator-=(Polynomial<T>o){*this=(*this)-o;return*this;}Polynomial<T>operator*(Polynomial<T>o)const{int n=1;while(n<2ll*std::max(N(),o.N()))n*=2;std::vector<T>aPoints=this->FT(n,false);std::vector<T>bPoints=o.FT(n,false);Polynomial<T>output;for(int i=0;i<n;++i)output.coeff.push_back(aPoints[i]*bPoints[i]);return output.FT(n,true);}Polynomial<T>operator*=(Polynomial<T>o){*this=(*this)*o;return*this;}Polynomial<T>operator*(T a)const{Polynomial*copy=new Polynomial(*this);for(int i=0;i<N();++i)copy->coeff[i]*=a;return*copy;}Polynomial<T>operator*=(T a){*this=(*this)*a;return*this;}Polynomial<T>operator/(Polynomial<T>o)const{assert(N()>=o.N());int divisorDeg=N()-o.N()+1;Polynomial<T>dRev=(this->rev()*o.rev().inv(divisorDeg)).mod(divisorDeg);Polynomial<T>d=dRev.rev();return d;}Polynomial<T>operator/=(Polynomial<T>o){*this=(*this)/o;return*this;}Polynomial<T>operator%(Polynomial<T>o)const{assert(N()>=o.N());Polynomial<T>r=*this-*this/o*o;return r;}Polynomial<T>operator%=(Polynomial<T>o){*this=(*this)%o;return*this;}private:std::vector<Polynomial<T>>buildSubproduct(std::vector<T>points)const{int treeSize=1;while(treeSize<points.size())treeSize*=2;std::vector<Polynomial<T>>v=std::vector<Polynomial<T>>(treeSize);for(int i=0;i<points.size();++i)v[i+treeSize]=Polynomial<T>({-points[i],1ll});for(int i=points.size();i<treeSize;++i)v[i+treeSize]=Polynomial<T>({1ll});for(int node=treeSize-1;node>=1;--node){v[node]=v[node*2]*v[node*2+1];}}std::vector<T>fastEval_(std::vector<Polynomial<T>>&v,int node=1)const{if(2*node>=v.size()){return{coeff[0]};}std::vector<T>leftVals=(*this%v[node*2]).fastEval(v,node*2);std::vector<T>rightVals=(*this%v[node*2+1]).fastEval(v,node*2+1);leftVals.insert(leftVals.end(),rightVals.begin(),rightVals.end());return leftVals;}public:std::vector<T>fastEval(std::vector<T>points)const{std::vector<Polynomial<T>>v=buildSubproduct(points);return fastEval_(v);}};template<typename T>std::ostream&operator<<(std::ostream&out,const Polynomial<T>&val){val.print(out);return out;}};
#include<assert.h>
#include<limits>
#include<set>
#include<vector>
namespace DS{  template<typename Iterator>using value_type=typename std::iterator_traits<Iterator>::value_type;  template<typename T>std::map<value_type<T>,value_type<T>>coordCompressMap(T begin,T end,int startI=0){std::map<value_type<T>,value_type<T>>compressed;int i=startI;for(auto val=begin;val!=end;++val,++i){compressed[*val]=i;}return compressed;}  template<typename T>void coordCompressTransform(T begin,T end,int startI=0){std::map<value_type<T>,value_type<T>>m=coordCompressMap(begin,end,startI);for(T i=begin;i!=end;i++)*i=m[*i];}  template<typename T>class Range{  private:T lVal,rVal;bool lInclusive,rInclusive;public:Range(T lVal,T rVal,bool lInclusive=true,bool rInclusive=true):lVal(lVal),rVal(rVal),lInclusive(lInclusive),rInclusive(rInclusive){assert(lVal<=rVal);}  std::ostream&print(std::ostream&out=std::cout,bool newLine=false)const{out<<(lInclusive? '[' : '(');out<<lVal<< "," <<rVal;out<<(rInclusive? ']' : ')');if(newLine)out<< '\n';return out;}  const T&l()const{return&lVal;}const T&r()const{return&rVal;}T length()const{return(rVal-lVal-(rInclusive?std::numeric_limits<T>::lowest():0)-(lInclusive?std::numeric_limits<T>::lowest():0));}bool isNull()const{return length()==0;}  bool contains(const Range<T>&o)const{return true;}bool touches(const Range<T>&o)const{return true;}bool overlaps(const Range<T>&o)const{return true;}Range<T>intersect(const Range<T>&o)const{return true;}Range<T>operator*(const Range<T>&o)const{return intersect(o);}bool operator<(const Range<T>o)const{if(lVal==o.lVal)return rVal<o.rVal;return lVal<o.lVal;}bool operator>(const Range<T>o)const{if(lVal==o.lVal)return rVal>o.rVal;return lVal>o.lVal;}bool operator<=(const Range<T>o)const{if(lVal==o.lVal)return rVal<=o.rVal;return lVal<=o.lVal;}bool operator>=(const Range<T>o)const{if(lVal==o.lVal)return rVal>=o.rVal;return lVal>=o.lVal;}  std::pair<Range<T>,Range<T>>split(T val){}}; template<typename T>std::ostream&operator<<(std::ostream&out,const Range<T>&val){val.print(out);return out;}  template<typename T>class Ranges:public std::set<Range<T>>{  private:public:  using std::set<Range<T>>::set;  void _cleanup(){  }  bool contains(const Ranges<T>&o)const{return true;}bool overlaps(const Ranges<T>&o)const{return true;}Ranges<T>getIntersect(const Ranges<T>&o)const{return true;}Ranges<T>operator*(const Ranges<T>&o)const{return getIntersect(o);}Ranges<T>getUnion(const Ranges<T>&o)const{return true;}Ranges<T>operator+(const Ranges<T>&o)const{return getUnion(o);}Ranges<T>getComplement(T rangeStart=std::numeric_limits<T>::min(),T rangeEnd=std::numeric_limits<T>::max())const{}Ranges<T>operator~()const{return getComplement();}bool isDisjoint()const{return true;}Ranges<T>flatten()const{}  Range<T>split(T val){}Range<T>splits(std::vector<T>val){}}; };namespace DS{  template<typename T>class Segtree{  private:ll l,r,m;T minVal,maxVal,sumVal;T lazyVal=T(0);short lazyMode=0;  Segtree*lChild=nullptr,*rChild=nullptr;  void push(){if(l==r)return;if(lChild==nullptr)lChild=new Segtree(l,m);if(rChild==nullptr)rChild=new Segtree(m+1,r);if(lazyMode==2){  lChild->minVal=lazyVal;rChild->minVal=lazyVal;lChild->maxVal=lazyVal;rChild->maxVal=lazyVal;lChild->sumVal=lazyVal*T(m-l+1);rChild->sumVal=lazyVal*T(r-(m+1)+1);lChild->lazyVal=lazyVal;rChild->lazyVal=lazyVal;lChild->lazyMode=2;rChild->lazyMode=2;}else if(lazyMode==1){  lChild->minVal+=lazyVal;rChild->minVal+=lazyVal;lChild->maxVal+=lazyVal;rChild->maxVal+=lazyVal;lChild->sumVal+=lazyVal*T(m-l+1);rChild->sumVal+=lazyVal*T(r-(m+1)+1);lChild->lazyVal+=lazyVal;rChild->lazyVal+=lazyVal;if(lChild->lazyMode==0)lChild->lazyMode=1;if(rChild->lazyMode==0)rChild->lazyMode=1;}lazyVal=T(0);lazyMode=0;}  void pull(){minVal=std::min(lChild->minVal,rChild->minVal);maxVal=std::max(lChild->maxVal,rChild->maxVal);sumVal=lChild->sumVal+rChild->sumVal;}public:  Segtree(ll n):l(0),r(n-1){assert(0<=l&&l<=r);m=(l+r)/2;minVal=maxVal=sumVal=0;}  Segtree(ll _l,ll _r,T initVal=0):l(_l),r(_r){assert(0<=l&&l<=r);m=(l+r)/2;minVal=maxVal=sumVal=lazyVal=initVal;lazyMode=2;}  Segtree(Segtree<T>&t){*this=t;}  Segtree(Segtree<T>t,ll _l,ll _r):l(_l),r(_r){assert(0<=l&&l<=r);m=(l+r)/2;for(ll i=_l;i<=_r;++i)set(i,t.getVal(i));}  Segtree(Segtree<T>_lChild,Segtree<T>_rChild):l(_lChild.l),r(_rChild.r),lChild(&_lChild),rChild(&_rChild){assert(0<=l&&l<=r);assert(lChild->r+1==rChild->l);m=(l+r)/2;minVal=std::min(lChild->minVal,rChild->minVal);maxVal=std::max(lChild->maxVal,rChild->maxVal);sumVal=lChild->sumVal+rChild->sumVal;}inline bool covers(ll i)const{return l<=i&&i<=r;}inline bool covers(ll tl,ll tr)const{return l<=tl&&tl<=tr&&tr<=r;}inline bool coveredBy(ll tl,ll tr)const{return tl<=l&&r<=tr;}inline bool touching(ll tl,ll tr)const{return tl<=r&&l<=tr&&tl<=tr;}  void print(std::ostream&out=std::cout,bool newLine=false){for(ll i=l;i<=std::min(l+20,r);++i)out<<getVal(i)<< ' ';if(newLine)out<< '\n';}  void printDebug(std::ostream&out=std::cout,bool newLine=false){out<< '[' <<l<< ".." <<r<< "]std::min=" <<minVal<< ",std::max=" <<maxVal<< ",sum=" <<sumVal;if(newLine)out<< '\n';}  Segtree*add(ll tl,ll tr,T x,bool persistent=false){if(tl>r||l>tr)return this;push();Segtree*newNode=persistent?new Segtree(*this):this;if(coveredBy(tl,tr)){newNode->minVal+=x;newNode->maxVal+=x;newNode->sumVal+=x*T(r-l+1);newNode->lazyVal+=x;if(newNode->lazyMode==0)newNode->lazyMode=1;}else if(touching(tl,tr)){newNode->lChild=lChild->add(tl,tr,x,persistent);newNode->rChild=rChild->add(tl,tr,x,persistent);newNode->pull();}return newNode;}Segtree*add(ll i,T x){return add(i,i,x);}  Segtree*set(ll tl,ll tr,T x,bool persistent=false){if(tl>r||l>tr)return this;push();Segtree*newNode=persistent?new Segtree(*this):this;if(coveredBy(tl,tr)){newNode->minVal=x;newNode->maxVal=x;newNode->sumVal=x*T(r-l+1);newNode->lazyVal=x;newNode->lazyMode=2;}else if(touching(tl,tr)){newNode->lChild=lChild->set(tl,tr,x,persistent);newNode->rChild=rChild->set(tl,tr,x,persistent);newNode->pull();}return newNode;}Segtree*set(ll i,T x){return set(i,i,x);}  void clear(){set(l,r,T(0));}  T getMin(ll tl,ll tr){if(!touching(tl,tr))return std::numeric_limits<T>::max();if(coveredBy(tl,tr))return minVal;push();return std::min(lChild->getMin(tl,tr),rChild->getMin(tl,tr));}  T getMin(){return getMin(l,r);}  T getMax(ll tl,ll tr){if(!touching(tl,tr))return std::numeric_limits<T>::min();if(coveredBy(tl,tr))return maxVal;push();return std::max(lChild->getMax(tl,tr),rChild->getMax(tl,tr));}  T getMax(){return getMax(l,r);}  T getSum(ll tl,ll tr){if(!touching(tl,tr))return T(0);  else if(coveredBy(tl,tr))return sumVal;push();return lChild->getSum(tl,tr)+rChild->getSum(tl,tr);  }  T getSum(){return getSum(l,r);}ll getMinIndexFirst(ll tl,ll tr,T target){if(!touching(tl,tr))return-1;if(coveredBy(tl,tr)&&target==minVal){Segtree*node=this;while(node->l!=node->r){node->push();node=node->lChild->minVal==target?node->lChild:node->rChild;}return node->l;}push();  ll lIndex=lChild->getMinIndexFirst(tl,tr);if(lIndex!=-1)return lIndex;return rChild->getMinIndexFirst(tl,tr);}  ll getMinIndexFirst(ll tl,ll tr){T target=getMin(tl,tr);return getMinIndexFirst(tl,tr,target);}  ll getMinIndexFirst(){return getMinIndexFirst(l,r);}ll getMinIndexLast(ll tl,ll tr,T target){if(!touching(tl,tr))return-1;if(coveredBy(tl,tr)&&target==minVal){Segtree*node=this;while(node->l!=node->r){node->push();node=node->rChild->minVal==target?node->rChild:node->lChild;}return node->l;}push();  ll rIndex=rChild->getMinIndexLast(tl,tr);if(rIndex!=-1)return rIndex;return lChild->getMinIndexLast(tl,tr);}  ll getMinIndexLast(ll tl,ll tr){T target=getMin(tl,tr);return getMinIndexLast(tl,tr,target);}  ll getMinIndexLast(){return getMinIndexLast(l,r);}ll getMaxIndexFirst(ll tl,ll tr,T target){if(!touching(tl,tr))return-1;if(coveredBy(tl,tr)&&target==maxVal){Segtree*node=this;while(node->l!=node->r){node->push();node=node->lChild->maxVal==target?node->lChild:node->rChild;}return node->l;}push();  ll lIndex=lChild->getMaxIndexFirst(tl,tr);if(lIndex!=-1)return lIndex;return rChild->getMaxIndexFirst(tl,tr);}  ll getMaxIndexFirst(ll tl,ll tr){T target=getMax(tl,tr);return getMaxIndexFirst(tl,tr,target);}  ll getMaxIndexFirst(){return getMaxIndexFirst(l,r);}ll getMaxIndexLast(ll tl,ll tr,T target){if(!touching(tl,tr))return-1;if(coveredBy(tl,tr)&&target==maxVal){Segtree*node=this;while(node->l!=node->r){node->push();node=node->rChild->maxVal==target?node->rChild:node->lChild;}return node->l;}push();  ll rIndex=rChild->getMaxIndexLast(tl,tr);if(rIndex!=-1)return rIndex;return lChild->getMaxIndexLast(tl,tr);}  ll getMaxIndexLast(ll tl,ll tr){T target=getMax(tl,tr);return getMaxIndexLast(tl,tr,target);}  ll getMaxIndexLast(){return getMaxIndexLast(l,r);}  std::vector<ll>getMinIndexes(){std::vector<ll>output;getMinIndexes(output);return output;}std::vector<ll>getMinIndexes(std::vector<ll>&output){if(l==r)output.push_back(l);else{push();if(lChild->minVal==minVal)lChild->getMinIndexes(output);if(rChild->minVal==minVal)rChild->getMinIndexes(output);}return output;}  std::vector<ll>getMaxIndexes(){std::vector<ll>output;getMaxIndexes(output);return output;}std::vector<ll>getMaxIndexes(std::vector<ll>&output){if(l==r)output.push_back(l);else{push();if(lChild->maxVal==maxVal)lChild->getMaxIndexes(output);if(rChild->maxVal==maxVal)rChild->getMaxIndexes(output);}return output;}  T getVal(ll i){assert(covers(i)&& "Invalid index");push();if(l==r){assert(minVal==maxVal&&maxVal==sumVal&& "AHH implementation broken");return minVal;}else if(i<=m)return lChild->getVal(i);else return rChild->getVal(i);}T operator[](ll i){return getVal(i);}};  template<typename T>std::ostream&operator<<(std::ostream&out,Segtree<T>tree){tree.print(out);return out;}};namespace DS{  template<typename T>std::vector<T>chunkQueries(std::vector<std::pair<int,int>>&queries_,std::function<void(int)>add,std::function<void(int)>rem,std::function<T(int,int)>answer){std::vector<std::pair<std::pair<int,int>,int>>queries;for(int i=0;i<(int)queries_.size();++i)queries.push_back({queries_[i],i});sort(queries.begin(),queries.end(),[](std::pair<std::pair<int,int>,int>a,std::pair<std::pair<int,int>,int>b){return std::make_pair(a.first.first/SQRT_MAXN,a.first.second)<std::make_pair(b.first.first/SQRT_MAXN,b.first.second);});std::vector<T>ans(queries_.size());int l=1,r=1;add(1);for(auto&query:queries){while(l>query.first.first){l--;add(l);}while(l<query.first.first){rem(l);l++;}while(r>query.first.second){rem(r);r--;}while(r<query.first.second){++r;add(r);}ans[query.second]=answer(l,r);}return ans;}};using namespace std;using namespace DS;ll N,M,T,arr[MAXN];void solve(){}signed main(){std::cin.tie(0);ios::sync_with_stdio(0);solve();}}